pragma solidity ^0.4.24;



contract CryptoChat {
    
    struct User {
        string username;
        address addr;
        // Messages stores with a JSON format, containing the RSA cipher
        // text and the digital sign from the sender.
        string[] recv_messages;
        // Since the cipher for receiver and sender is different, 
        // a message has to be stored in two ciphers seperately.
        string[] sent_messages;
        string pubKey;
        bool exists;
        //signature is used to verify the user is created by the right address.
        // web3.personal.sign is used to generate the signature
        string signature;
        //keySig is used to verify the public key, generated by RSA signing.
        string keySig;
    }
    mapping(address => User) users;
    mapping(string => address) name_addr;

    function getRecvMsgCount() public view returns (uint){
        require(users[msg.sender].exists, "User does not exist");
        return users[msg.sender].recv_messages.length;
    }
    
    function getUserRecvMsg(uint index) public view returns (string) {
        require(users[msg.sender].exists, "The user does not exist");
        require(users[msg.sender].recv_messages.length > index, "The queried index is out of range");
        return users[msg.sender].recv_messages[index];
    }
    
    function getSentMsgCount() public view returns (uint){
        require(users[msg.sender].exists, "Sender has not created an account.");
        return users[msg.sender].sent_messages.length;
    }
    
    function getUserSentMsg(uint index) public view returns (string) {
        require(users[msg.sender].exists, "User does not exist."); 
        require(users[msg.sender].sent_messages.length > index, "User does not exists");
        return users[msg.sender].sent_messages[index];
    }
    
    function sendMessage(address targetUser, string memory recv_msg, string memory send_msg) public {
        require(users[targetUser].exists, "Sender does not exist");
        require(users[msg.sender].exists, "Reciver does not exist");
        users[targetUser].recv_messages.push(recv_msg);
        users[msg.sender].sent_messages.push(send_msg);
    }
    
    function getCurrentAddr() public view returns (address) {
        return msg.sender;
    }
    
    function hasUser(address target) public view returns (bool) {
        return users[target].exists;
    }
    
    // Only add user when this function returns 0.
    //Returns ERROR code to represent what kinds of error were encountered.
    function checkNewUser(string name, string pubKey) public view returns (uint) {
        if (users[msg.sender].exists) {
            //1 - represent user already exists.
            return 1;
        }
        if (bytes(name).length > 20) {
            //2 - represent username too long
            return 2;
        }
        if (bytes(pubKey).length > 300) {
            //3 - represent the public key being too long
            return 3;
        }
        if (name_addr[name] != 0x0) {
            //4 - username already exists.
            return 4;
        }
        //OK
        return 0;
    }
    

    function addUser(string name, string pubKey, string sign, string keySig) public  {
        require(!users[msg.sender].exists, "User already exist");
        require(bytes(name).length <= 20, "Username is too long");
        require(bytes(pubKey).length <= 300, "Public key is too long");
        require(name_addr[name] == 0x0, "Username is already used by other user");
        users[msg.sender] = User({
            username: name,
            addr: msg.sender,
            pubKey: pubKey,
            recv_messages: new string[](0),
            sent_messages: new string[](0),
            exists: true,
            signature: sign,
            keySig: keySig
        });
        name_addr[name] = msg.sender;
    }

    function getAddrFromName(string username) public view returns (address) {
        return name_addr[username];
    }
    
    function sendEther(address target) public payable {
        require(users[target].exists, "Sender does not exist");
        require(users[msg.sender].exists, "Receiver does not exist");
        target.transfer(msg.value);
    }
    
    function getUsername(address target) public view returns (string memory) {
        require(users[target].exists, "Queried user does not exist");
        return users[target].username;
    }
    
    function getUserPublicKey(address target) public view returns (string memory) {
        require(users[target].exists, "Queried user does not exist");
        return users[target].pubKey;
    }

    function getUserSignature(address target) public view returns (string memory) {
        require(users[target].exists, "Queried user does not exist");
        return users[target].signature;
    }

    function getUserKeySig(address target) public view returns (string memory) {
        require(users[target].exists, "Queried user does not exist");
        return users[target].keySig;
    }
}